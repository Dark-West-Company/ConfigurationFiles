name: Deploy Config Files

on:
  push:
    branches: [ master ]
  pull_request:
    branches: [ master ]
    types: [ closed ]
  workflow_dispatch:

jobs:
  validate:
    runs-on: ubuntu-latest
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Validate config mapping
      run: |
        # Check if config-mapping.json is valid JSON
        python -m json.tool config-mapping.json > /dev/null
        echo "‚úÖ config-mapping.json is valid JSON"
        
        # Check that all mapped files exist
        python3 << 'EOF'
        import json
        import os
        
        with open('config-mapping.json', 'r') as f:
            mappings = json.load(f)
        
        missing_files = []
        for local_path, mapping_value in mappings.items():
            if not os.path.exists(local_path):
                missing_files.append(local_path)
        
        if missing_files:
            print("‚ùå Missing config files:")
            for file in missing_files:
                print(f"  - {file}")
            # Do not exit, just print missing files
        else:
            print("‚úÖ All mapped config files exist")
        EOF

  deploy:
    needs: validate
    runs-on: ubuntu-latest
    if: github.event_name == 'push' || (github.event_name == 'pull_request' && github.event.pull_request.merged == true) || github.event_name == 'workflow_dispatch'
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Setup Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.x'
        
    - name: Deploy config files via FTP
      env:
        FTP_SERVER: ${{ secrets.FTP_SERVER }}
        FTP_USERNAME: ${{ secrets.FTP_USERNAME }}
        FTP_PASSWORD: ${{ secrets.FTP_PASSWORD }}
        FTP_PORT: ${{ secrets.FTP_PORT }}
        SERVER_BASE: ${{ secrets.SERVER_BASE }}
      run: |
        python3 << 'EOF'
        import json
        import os
        import ftplib
        import urllib.parse
        from pathlib import Path
        import glob

        # Load configuration mapping
        with open('config-mapping.json', 'r') as f:
            mappings = json.load(f)

        # FTP connection details
        ftp_server = os.environ['FTP_SERVER']
        ftp_username = os.environ['FTP_USERNAME']
        ftp_password = os.environ['FTP_PASSWORD']
        ftp_port = int(os.environ.get('FTP_PORT', '21'))

        # SERVER_BASE is required - abort if not set
        server_base = os.environ.get('SERVER_BASE')
        if not server_base:
            print("‚ùå ERROR: SERVER_BASE environment variable is not set!")
            print("   Please configure the SERVER_BASE secret in GitHub repository settings.")
            print("   Example value: VORPCore_123456.base")
            exit(1)

        print(f"üîó Connecting to FTP server: {ftp_server}:{ftp_port}")
        print(f"üîß Using server base: {server_base}")

        def get_mapping_info(mapping_value):
            """Extract path and filename from mapping value"""
            if isinstance(mapping_value, dict):
                path = urllib.parse.unquote(mapping_value['path'])
                path = path.replace('{SERVER_BASE}', server_base)
                filename = mapping_value.get('filename', Path(path).name)
                return path, filename
            else:
                raise ValueError(f"Invalid mapping format: {mapping_value}. Expected object with 'path' and optional 'filename' keys.")

        def create_ftp_directory(ftp, path):
            dirs = [d for d in path.split('/') if d]
            current_path = ""
            for dir_name in dirs:
                current_path += f"/{dir_name}"
                try:
                    ftp.cwd(f"/{current_path}")
                except ftplib.error_perm:
                    try:
                        parent_path = "/".join(current_path.split('/')[:-1])
                        if parent_path:
                            ftp.cwd(f"/{parent_path}")
                        else:
                            ftp.cwd('/')
                        ftp.mkd(dir_name)
                        print(f"üìÅ Created directory: {current_path}")
                    except ftplib.error_perm as e:
                        print(f"‚ö†Ô∏è  Could not create directory {current_path}: {e}")

        try:
            # Connect to FTP server
            ftp = ftplib.FTP()
            ftp.connect(ftp_server, ftp_port)
            ftp.login(ftp_username, ftp_password)

            print("‚úÖ Connected to FTP server")

            deployed_count = 0

            # Deploy config-mapped files
            for local_path, mapping_value in mappings.items():
                if os.path.exists(local_path):
                    try:
                        remote_path, target_filename = get_mapping_info(mapping_value)
                        remote_dir = str(Path(remote_path).parent)
                        print(f"üì¶ Processing: {local_path}")
                        print(f"   ‚Üí Target: {remote_path}")
                        if target_filename != Path(local_path).name:
                            print(f"   ‚Üí Renaming: {Path(local_path).name} ‚Üí {target_filename}")
                        ftp.cwd('/')
                        if remote_dir and remote_dir != '.' and remote_dir != '/':
                            create_ftp_directory(ftp, remote_dir)
                            ftp.cwd(f"/{remote_dir}")
                        with open(local_path, 'rb') as file:
                            ftp.storbinary(f'STOR {target_filename}', file)
                        print(f"‚úÖ Deployed: {local_path} ‚Üí {remote_path}")
                        deployed_count += 1
                    except Exception as e:
                        print(f"‚ùå Failed to deploy {local_path}: {e}")
                        import traceback
                        traceback.print_exc()
                else:
                    print(f"‚ö†Ô∏è  File not found: {local_path}")

            # Deploy all PNG images in images/ to vorp_inventory html img/items
            images_dir = "images"
            remote_img_dir = f"server/txData/{server_base}/resources/[VORP]/vorp_inventory/html/img/items"
            png_files = glob.glob(f"{images_dir}/*.png")
            if png_files:
                print(f"üñºÔ∏è Found {len(png_files)} PNG images to deploy.")
                create_ftp_directory(ftp, remote_img_dir)
                ftp.cwd(f"/{remote_img_dir}")
                for img_path in png_files:
                    img_filename = Path(img_path).name
                    try:
                        with open(img_path, "rb") as img_file:
                            ftp.storbinary(f"STOR {img_filename}", img_file)
                        print(f"‚úÖ Deployed image: {img_path} ‚Üí {remote_img_dir}/{img_filename}")
                        deployed_count += 1
                    except Exception as e:
                        print(f"‚ùå Failed to deploy image {img_path}: {e}")
                        import traceback
                        traceback.print_exc()
            else:
                print("‚ÑπÔ∏è No PNG images found in images/.")

            ftp.quit()
            print(f"\nüéâ Deployment complete! {deployed_count} files deployed successfully.")

        except Exception as e:
            print(f"‚ùå FTP connection failed: {e}")
            import traceback
            traceback.print_exc()
            exit(1)
        EOF
        
    - name: Create deployment summary
      if: always()
      env:
        SERVER_BASE: ${{ secrets.SERVER_BASE }}
      run: |
        echo "## üöÄ Deployment Summary" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "- **Repository**: ${{ github.repository }}" >> $GITHUB_STEP_SUMMARY
        echo "- **Commit**: ${{ github.sha }}" >> $GITHUB_STEP_SUMMARY
        echo "- **Triggered by**: ${{ github.event_name }}" >> $GITHUB_STEP_SUMMARY
        echo "- **Branch**: ${{ github.ref_name }}" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "### Config Files Processed" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        python3 << 'EOF' >> $GITHUB_STEP_SUMMARY
        import json
        import urllib.parse
        import os
        from pathlib import Path
        
        with open('config-mapping.json', 'r') as f:
            mappings = json.load(f)
        
        # SERVER_BASE is required - show error if not set
        server_base = os.environ.get('SERVER_BASE')
        if not server_base:
            print("- ‚ùå **ERROR**: SERVER_BASE environment variable is not set!")
            print("- Please configure the SERVER_BASE secret in GitHub repository settings.")
            exit(0)  # Don't fail the summary step, just show the error
        
        for local_path, mapping_value in mappings.items():
            if isinstance(mapping_value, dict):
                # Object format
                remote_path = urllib.parse.unquote(mapping_value['path'])
                # Replace {SERVER_BASE} placeholder with actual value
                remote_path = remote_path.replace('{SERVER_BASE}', server_base)
                target_filename = mapping_value.get('filename', Path(remote_path).name)
                if target_filename != Path(local_path).name:
                    print(f"- `{local_path}` ‚Üí `{remote_path}` (renamed to `{target_filename}`)")
                else:
                    print(f"- `{local_path}` ‚Üí `{remote_path}`")
            else:
                print(f"- ERROR: Invalid mapping format for `{local_path}`")
